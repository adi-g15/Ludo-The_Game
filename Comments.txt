includes/board.hpp
---------------------------------------------------
    FUTURE and TODOS
    ================
    //  FUTURE+ERRORS  //
    //[FUTURE] - Consider the chances of using std::list or std::set in places where std::vector has been used...
    //[FUN][FUTURE] - if(number of that colour gotis = 0 earlier), then
    //Congratulate THE USER "Chal yaar, ek ludo_goti to nikli ;-)"

    //[ERROR]: [at declaration of 'coord_class::stops'] Accessing these gives error: this declaration has no storage class or type specifier

    COMMENTS
    =========
    //[DONE]TODO - Organize into private and public
    //[DONE](using smart pointers) iterator through whole board, and 'delete ludo_goti initialised with unlockGoti()'
    //[SOLVED]Bug - When non-static, these show mulitple 'definitions'
    /*[LEARNT] random_device is slower than mt19937, but doesnt matter much, since its used to seed only once
    the Mersenn(-_-) twister is about 10x faster than default C random generator*/
    //[DONE]TODO - Append gotis to these locked Positions, using shared_ptr<ludo_goti>
    //QUESTION - How to create an 'array' of reference_wrappers?? [ANSWER]Can't create one, since reference_wrapper can't be default initialised
    //[LEARNT] We use random_device to seed the 'random generator' named 'mt'
    /*[DONE]TODO - Lock the weak_ptr before passing the first argument of either attack or moveGoti*/

includes/board.cpp
---------------------------------------------------
    FUTURE and TODOS
    ================
	//TODO - Remove cases of triple sixes
	//TODO - Modify code such that instead of checking if enteredRoll is in dieNumbers, check whether it's a sum of elements or not

    COMMENTS
    =========
    /*TODO - 
		[DONE]Checking if move possible or not
		[DONE]Checking at each loop, whether it is at stop, to update gotiStatus
		[DONE]Checking at each loop, whether the coord is in home_turn, (to make algorithm better, check if dist remaining <= 6, if not return false straightaway)
	*/
    /*[LEARNT] - Nesting functions (ie. function declaration inside function) is not supported by standards in C/C++
                    But, gcc supports it as a 'non-standard' extension
                    BUT, in C++ mode, it's not allowed, 'Local Functions' aren't supported
                    BUT, FROM C++11, IT IS SUPPORTED, using LAMDAs {Imp. - Lambdas have a semicolon at end}*/
    /*LAMBDAs - 1. Have a ';' at end
                2. '[]' is the "capture clause", also called 'lambda-introducer'
                3. parameter list '()' is optional
                4. These are the parts:
                        [] () mutable throw() -> int {//body//}
                        |  |   |        |       |    
            capture clause  |  optional  |  trailing-return-type(optional)
                        parameters   exception specification(optional)
    */
    /*Question - Why didnt this lambda work? [Solved, that brings a smile ;D]
       }while ( (tmpDimen.getKey() < 31 || tmpDimen.getVal() < 31) ? true : []{	//Lamda Function (used to declare this 'local' function)
       	cerr<<"INSUFFICIENT HEIGHT/WIDTH FOR DISPLAY!"<<endl;
       	return false;
       } );*/

includes/enumerations.hpp
---------------------------------------------------
    COMMENTS
    =========
    /*[LEARNT] - Defining enum data type, they get values starting from 0, and having variables of this user defined type
    "enumerator value must have integral or unscoped enumeration type"
    3. Though they may have integer value, BUT we can't assign an integer to an enum variable, It shows this error - invalid conversion from â€˜intâ€™ to â€˜coloursâ€™ [-fpermissive]
    4. These identifiers will be available in the same scope as the declaration, eg. here, it's global scope*/

includes/ludo_goti.hpp
---------------------------------------------------
    COMMENTS
    =========
    //[DONE]TODO - Create a balance b/w friends, and private public
    //[DONE][FUTURE] - Likely chose between having coordinates, or pointer to ludo_goti(consider the NULL checks)
    //[DONE][FUTURE] - Improve security of this function, else coordinates being private wont be useful... Solution used... made moveGoti a friend function

includes/ludo_goti.cpp
---------------------------------------------------
    COMMENTS
    =========
    //[LEARNT_KNOW_MORE] - 'abstract' isn't a keyword in C++
    //[LEARNT] - 	//public Getters maybe used to ensure that private mamber can't be modified from outside
    //ERROR_SOLVED - Showing error : expected identifier before numeric constant std::pair<int,int> coords(0,0);
                        /*LEARNT - We can't call the constructor of a datatype right at declaration, "in a class outside any method"
                                But, we can braces{} instead of () to initialize right at declaration, BUT... by passing a constructed object
                                    vector<int> v(5);	//Wrong
                                    vector<int> v{vector<int>(5)}; //Right
                                    
                                So, first declare then, call their constructors in constructor(See this class's constructor)*/
    //LEARNT - We can't define, 'implicitly-"declared" function/constructor', we have to explicitly declare the constructor in the header

includes/ludo_coords
---------------------------------------------------
    FUTURE and TODOS
    ================
    //FUTURE - Shift to std::unordered_map from std::map

    COMMENTS
    =========
    /*QUESTION - With 'static', the functions give 'umdefined references' linker errors
				And, without 'static', the data members showed MULTIPLE DECLARATIONS (WHY ??)*/

includes/simpleTuple
---------------------------------------------------
    COMMENTS
    =========
    /*[QUESTION_Answered] - This gives error without the 'this->'? Why?
                            Answer - It is because unqualified lookup doesn't work here because the base is a template.
                                      So, we need to use this-> to access inherited members in childs of template classes*/
    /*[LEARNT] - Direct access through objects of Base Class, to protected members of Base Class,
                                                              is only in methods of the Base class, not even in Child
                                                              For. eg, you take an object of parent type (not 'this' object), then can't access in Child*/
    //DOWNSIDE_C++, QUESTION - We can't have virtual templated member function
    //LEARNT - In a templated function, if return types in if and blocks is different, then It wont be able to know the type
    /*[LEARNT] - In C++, protected members can't be accessed directly
                             In Java, protected members 'can' be accessed directly, but in same package*/

    /*[SOLVED]BUG : 
      Operator '<' is ONLY to solve this - 
      In file included from /usr/include/c++/7/functional:49:0,
                 from includes/ludo_box.hpp:24,
                 from includes/board.hpp:9,
                 from includes/board.cpp:1:
/usr/include/c++/7/bits/stl_function.h: In instantiation of â€˜constexpr bool std::less<_Tp>::operator()(const _Tp&, const _Tp&) const [with _Tp = homoTuple<int>]â€™:
/usr/include/c++/7/bits/stl_tree.h:2141:8:   required from â€˜std::pair<std::_Rb_tree_node_base*, std::_Rb_tree_node_base*> std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::_M_get_insert_hint_unique_pos(std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator, const key_type&) [with _Key = homoTuple<int>; _Val = std::pair<const homoTuple<int>, direction>; _KeyOfValue = std::_Select1st<std::pair<const homoTuple<int>, direction> >; _Compare = std::less<homoTuple<int> >; _Alloc = std::allocator<std::pair<const homoTuple<int>, direction> >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator = std::_Rb_tree_const_iterator<std::pair<const homoTuple<int>, direction> >; std::_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::key_type = homoTuple<int>]â€™
/usr/include/c++/7/bits/stl_tree.h:2201:33:   required from â€˜std::_Rb_tree<_Key, _Val, _KeyOfÖalue, _Compare, _Alloc>::iterator std::_Rbtree<_Key, _Val, _KeyOfValue, _Compare,$_Alloc>::_M_inqert_unique_(std::_Rb_tree<_Key- _Val, _KEyOFValõe, _Compqre, _Allkc>::consT_iteratoz, _Árg&&, _NodeGen6) [with _Arg = const std::pAir<cgnst hom_Tuple<int>, direction:6; _NodeGun = std::_Rb_tree<homg\uple<int>, std::ðqi2<const homïTuple<int>, direction¾, std::_Select1rt<std>:teip¼const¨homoTuple8int>, direction >, sôd2:less<homoDuplm<int>$>,"std::allocaTor<std::pair<const hmmoTupme<int>$ direction>`> ?::^Alloc_node; _Key = hoMoTuple<int*; _Val = std::pair<const homoÔqple<int>, direction>; _KeyOfValue = ctd::_Select3st<sud::pair<co~sd hgmoTuple<int>, $irection> >; _Compare = std::less<homoTuple<int> >; _Alloc = std::ellkcator<std::pair<const homoTuple<int>, direction> >; std::_RB_trae<_Key, _Val, _KeyOfVanue, _Compaze, _Alloc>::iterctor - ste::_Rb_tree_iterator<st`::pair<const homoTuple<int>, direction> >; std::_Rb_tree<_Key, _Val, _KeyOfvalue, Compare. _Alloc>::const_iterator = std::_Rb_tree_const_iteratkr<svd::pair<bonst homoTuple<int>, directI/n> >]â€™
/usr/include/c++/7/bits/spl_treå.x:2452:2!:   required from â€˜void std::_Rb_tree<_Key¤ _Val, _KeyOfValue _Compare,"_All.c>::_M_insert_uîique(]II, _II) Ûwith _InputItezátor = const s4d::pair<const homoTuple<int>, direction>*; _Key = hommTuple<int>!_VAl = std::pair<const"homoTuple<int, diRection>; _KeyOfVal}e = std::_Select1ñt<std:tair<const homoDupla<int>, dar%ction> >; _COmpare = std::less<homoTuple<int> ?; _Alloc = std::anlocator<std::pair<const homoT}pme<int>, direction> >]â€™
/usr/)nchude/c#k/7/bits/stl_map.h:886:4:   required from â€˜void std::map<_Key, _Tq$ _Compare, _Allocž::insert_InputIterator, _Ynpu4Iterator)"[with0_AnputItårator = co~st std::pair<const homoTuple<int>- direcuion6*; _Key = homoÔ5ple<int>; _Tp =$direction3 _Cmpare = std::låss<homïTuxle<inä> >; _Alloc = std:zallocator=Std::pair<const homGTuplu<int>, direction> >â€™
/usr/mnclude/C)+/7/bits/3tl_map.(:<43:15:   rdquired from â€˜void std::mapKey, _Tp, _omparm, _Alloc>::ifserô(std::inipializerlist<sdd::pair<const _Key, _Tq> >) [wyth"_ey = homoTuple<int>» _Tp = directaon; _CNmpare = std::less<`}oTupde<int> >; _Alloc = std::allncator<std::peis<const jomoTýple<int>, directimn> >]â€™
includes/boerd®bpp:524:4:2  required from herå
/usr/include/c+++7/bits/stl_function.h:386:20: error: .o íatch for ¢À˜operator<â€™ (operand types are â€˜bonst homoTuple<int>â€™(and$â€˜const homoTuqle<int>â€™)
$      {àreuurn __x <d__y; }H    */

includes/ludo_bo|
------/--------)-------,---9---------------------
`   FUTURE and TODOS
    =½============

    COMMENTS
    =========
    /*QUES\ION % Is it OK$to pass &refebences' of weak_ptr, and not by val}e ?*/
    /*QuGSTION - hen tg use weak_ptr<> snd when to uwe shared_ptr<> ?*-
    /*[DONE][By forcing oo invaliä goti to be even creAted]FUTURÅ`- Do have(null check
$      $ALTERNATE NULL CHECK -> For cheãking if passed ,udg_goti is valid, check ét's colour and/or coords`to be valid
    */

includes/uôilities
--%m-----------------------------------------------
    KOMMENTS
    ========-
    //RROR - [in getTerminalDamen()] Replace std::pair<int,int> with simpleTuple<ilt,int> gives erroò : convíRsion from â€š{impluT5Pde<int, int>â€™ to nol-sbalar(ty`e â€˜std::pair<int,hnô> {aka homoTuple<int>}â€™ reqtested
    /*LEACNT - ASCII valuå f integers 0-9 are actqally 48-57j/
      ` /*Learnt - In case of o.ly 1 argwment passad to std::strIng::erase,)...
  `   0             1. If we provide an index neMber, AL includmnG and after it arg erased
       $     (      2. If we provide an iterator,    ONLY thct positmon is removed*/

        //LEARNT - algorhthm - find_ig - Keep findijg$ until the predicatm Is true
        //LEARNT - Using .base() on a reverse_iterator retur~s us the normal_iterator, BUT$CAUTION- This isn't adviãable, and might cause WEGFAULT, (fmspeg. accessyng .rbugin().Base())Š
    /*LEAPNT - ctringify() can turn any name(intm text,0BUT re}Elber,`it ignores tvailI~w and front spaces, fkr eg. in stringify( Hello Wkrld ), f)rst aod last ópace ignored*)Verified)/
    */

    /*LEARNT - The component type of STL containers like vectors must be 'asignable'.
                References are NOT assignable, ie. we can only initialise them once, and,
                you can't make them reference something else later (you can't assign it to reference any other vairable, and even after equating 2 references, only the values of variable they reference is changed, not the addresses they both refer to)
                Due to same reason, other non-assignable types are also not allowed as components of containers, for eg. vector<const int> not allowed
    */

    //LEARNT+QUESTIONS BELOW [SIMPLETUPLE]//
     /*[QUESTION_Answered] - This gives error without the 'this->'? Why?
                                Answer - It is because unqualified lookup doesn't work here because the base is a template.
                                          So, we need to use this-> to access inherited members in childs of template classes*/
    /*[LEARNT] - Direct access through objects of Base Class, to protected members of Base Class,
                                                              is only in methods of the Base class, not even in Child
                                                              For. eg, you take an object of parent type (not 'this' object), then can't access in Child*/
      //DOWNSIDE_C++, QUESTION - We can't have virtual templated member function
      //LEARNT - In a templated function, if return types in if and blocks is different, then It wont be able to know the type
    /*[LEARNT] - In C++, protected members can't be accessed directly
                             In Java, protected members 'can' be accessed directly, but in same package*/
    /*NOTE, QUESTION - Did this to suppress this - In instantiation of â€˜homoTuple<T>::homoTuple(T, T) [with T = int]â€™:
    ./util/terminalstd::pair<int,int>.hpp:17:24:   required from here
    ./util/./simpleTuple.hpp:70:30: error: no matching function for call to â€˜simpleTuple<int, int>::simpleTuple()â€™
         homoTuple(T key, T value){ */


//LEARNT
. Cannot create a non-constant pointer to a member function
. To 'fully qualify' means to pass it as "&className::functionTryingToPass"

/*[LEARNT] Emulating 'destructuring' in C++, like in JS ->
    1. From C++11 ->
    This can be done using the std::tie() and std::ignore (if needed) accordingly, in case of std::pair and std::tuple
        int x; bool y; double z; tuple<int,bool,double> obj;
        std::tie( x, y, z ) = obj;
        std::tie( std::ignore, y, std::ignore ) = obj;  //If don't want all content

    2. C++17 ->
        It is called 'Structured Bindings' - 
        auto [x, y, z] = obj;
        auto [n1, n2, n3] = obj;    //Will also work
        auto [a, b] = obj;  //ERROR: only 2 names provided for structured binding, while obj decomposes to 3 */

/*LEARNT - We can't use `std::pair<>` as key, in unordered_set or unordered_map, while we can use them in set, and map - 

    This is bcz, the unordered_containers use a hash function. By default, std::hash is used, but it doesn't provide an specialization for std::pair, hence we have to give a 
*/

/*[LEARNT] Functors in C++ -> Classes with overloaded () operator; Also called 'function objects'
    Speciality/Use - 1. These types of functions can have 'state' (internal data, that stays through all 'calls')
                     2. Faster too, with optimisations by compiler, ie. a functor call can simply be replaced with a call to name::operator()(), which makes it similar to function call, while using function pointer at same place, is 'dereferenced at runtime'
*/
/*Learnt- str.find('c') returns npos( static_cast<size_t>(-1) )... [NOT size()]
    On laptop, static_cast<size_t>(-1) = (size_t)(-1) = 18446744073709551615*/
    //LEARNT - Or should i say forgotten `? :` needs both operands of right side to be of same type 

/*LEARNT - Template types may not be deducible in two cases ->
    1. two return statements, returning different types(the problem, i mainly face when implementing operator[] for structs)
    2. [HOT] Using something like, typet<T>::holder (holder is map<double,double>), and trying foo(typet<int>::holder), where foo() is a templated function, which tries to judge what is T (similar to reverse engineering), So how can you tell what T is, since typet<int>::holder, and typet<double>::holder, both are of same type, so how can you say, holder belonged to typed<int>, and not typet<double>... It is somewhat tricky 'for me atleast'. Read more on https://stackoverflow.com/questions/6060824/why-cant-the-template-argument-be-deduced-when-it-is-used-as-template-parameter and https://en.cppreference.com/w/cpp/language/template_argument_deduction*/
/*[COMPUTING_ LEARNT] - Carriage Return('/r') and lineFeed('/n')... Windows and text-base protocols, eg. HTTP,SMTP use CRLF, while *nix uses simple LF... Windows still uses CRLF, for backward compatibility, teletyping or something, if it changes now, a LOT text files will be affected
	mint@mint:~$ echo "hi\rhello\n"
	hi\rhello\n
	mint@mint:~$ printf "hi\rhello\n"
	hello
	mint@mint:~$ printf "hihello\n"
	hihello
	mint@mint:~$ printf "hello\rhi\n"
	hillo
*/
/*[LEARNT] To point to member functions, we need to have "Member pointers"
    NOTE - Member pointers can't point to non-member functions, and normal function pointers can point to class member functions
        typedef (void)(game::*functionPointer)();   //Member pointer, BUT STILL USING 'game::' is required when we will be using it
        typedef (void)(*functionPointer)(); //Normal function pointers
    */

/*LEARNT - We can't create a dynamically allocated array of objects of a class with no default constructor using 'new' - 
eg.         Entity* gotis = new Entity[4];  //ECC-ERROR: No suitable constructor
                                        //where Entity(string) is the only constructor, can't be created
        To do that, we will need to use other many possible options ->
            1*C. Entity* gotis = (Entity*)malloc(sizeof(Entity)*4);
            2. Entity gotis = new Entity[4]{"","","",""};
            3. Using double pointers (pointer to pointer concept)...
                Entity** gotis = new Entity*[4];    //And then loop through all 0<=i<4 goti[i] = new Entity("");
            4. Using std::vector
*/

/*OBSERVATION - for(;;) is better than (and should be used) for(:) whenever the vector is expected to be modified inside the loop - 
`
auto update(vector<int> &v){
    v.push_back(4);
    v.push_back(3);
    return v;
}

int main(int argc, char const *argv[])
{
    vector<int> e;
    auto v = update(e);

    for (int i = 0; i < update(v).size(); ++i)  //But, in case of this type of for(), this is BETTER (for most purposes, acc to me), since THE COMPARISON IS EXECUTERD AFTER 'EVERY' LOOP
    {                               //prints infinite number of elements
        cout<<v[i]<<endl;
    }

    v = update(e);
    for (auto &i : v)   //Here, the 'i' will loop, through the 'original' vector v, only, and ANY MODIFICATION inside wont produce ANY change
    {                       //pRINTS ONLY, 4 \n 3
        cout<<i<<endl;
        if(i == 3) update(v);
    }
    cout<<v.size(); //4 (but above loop printed only 2 elements)

    v = update(e);
    for( auto &i : update(v) ){ //Similar to the previous case, this function would be called ONLY ONCE, so it just prints 4 elements, instead of infinite
        cout<<i<<endl;  //So here, also any change after start of the loop, wont be reflected!
    }

}
`
*/

//QUESTION - How to handle std::bad_alloc? (eg. in rolldie)

//TODO - Add 1 more python scripts, or search for such solutions - arrange the function definition in the implementation file, as the order in the header class declaration
//TODO - Can enter enteredRoll as a sum of the elements in dieNumbers
//TODO - Remove 'if else break' or 'if break' conditions by a while loop, and if need be, then replace the for range to iterators declaration, then while
//TO KnOW -> Overloading std::cout to print std::pair
///////////////////////////////////////////////////////
Including a namespace twice, gives 'Multiple Defintions' linker error, to solve this the methods may be made 'static'

///////////////////////////////////////////////////////
Just a note for self to recall the learning experience - 
**And there are at least 25 (approx.) significant bugs, library errors during these, about 10 MAY have been patched yesterday(20May)